template <class ValType>
TVector<ValType>::TVector(int s, int si)
{
} /*-------------------------------------------------------------------------*/
    if ((s < 1) || (s > MAX_VECTOR_SIZE))
        throw (s);
    if ((si < 0) || (si >= MAX_VECTOR_SIZE))
        throw(si);
    Size = s;
    StartIndex = si;
    pVector = new ValType[Size];
} 

template <class ValType> //конструктор копирования
TVector<ValType>::TVector(const TVector<ValType> &v)
{
} /*-------------------------------------------------------------------------*/
    Size = v.Size;
    StartIndex = v.StartIndex;
    pVector = new ValType[Size];
    for (int i = 0; i < Size; i++)
        pVector[i] = v.pVector[i];
} 

template <class ValType>
TVector<ValType>::~TVector()
{
    delete[]pVector;
    pVector = NULL;
} /*-------------------------------------------------------------------------*/

template <class ValType> // доступ
ValType& TVector<ValType>::operator[](int pos)
{
    if ((pos - StartIndex >= 0) && (pos - StartIndex < Size))
        return pVector[pos - StartIndex];
    else throw(pos);
} /*-------------------------------------------------------------------------*/

template <class ValType> // сравнение
bool TVector<ValType>::operator==(const TVector &v) const
{
    bool flag = 0;
    if ((Size == v.Size) & (StartIndex == v.StartIndex))
    {
        int count = 0;
        for (int i = 0; i < Size; i++)
            if ((pVector[i] == v.pVector[i]))
                count++;
        if (count == Size)
            flag = 1;
    }
    return flag;
} /*-------------------------------------------------------------------------*/

template <class ValType> // сравнение
bool TVector<ValType>::operator!=(const TVector &v) const
{
    bool flag = 1;
    for (int i = StartIndex; i < Size; ++i)
        if (pVector[i] == v.pVector[i])
            flag = 0;
    if ((Size != v.Size) || (StartIndex != v.StartIndex))
        flag = 1;
    return flag;
} /*-------------------------------------------------------------------------*/

template <class ValType> // присваивание
TVector<ValType>& TVector<ValType>::operator=(const TVector &v)
{
    if (*this != v)
    {
        if (Size != v.Size)
        {
            delete[] pVector;
            pVector = new ValType[v.Size];
        }
        Size = v.Size;
        StartIndex = v.StartIndex;
        for (int i = 0; i < Size; i++)
            pVector[i] = v.pVector[i];
    }
    return *this;
} /*-------------------------------------------------------------------------*/

template <class ValType> // прибавить скаляр
TVector<ValType> TVector<ValType>::operator+(const ValType &val)
{
    TVector tmp(Size, StartIndex);
    for (int i = 0; i < Size; i++)
        Tmp.pVector[i] += val;
    return Tmp;
} /*-------------------------------------------------------------------------*/

template <class ValType> // вычесть скаляр
TVector<ValType> TVector<ValType>::operator-(const ValType &val)
{
    TVector tmp(Size, StartIndex)
    for (int i = 0; i < Size; i++)
        Tmp.pVector[i] -= val;
    return Tmp;;
} /*-------------------------------------------------------------------------*/

template <class ValType> // умножить на скаляр
TVector<ValType> TVector<ValType>::operator*(const ValType &val)
{
    TVector tmp(Size, StartIndex);
    for (int i = 0; i < Size; i++)
        Tmp.pVector[i] *= val;
    return Tmp;
} /*-------------------------------------------------------------------------*/

template <class ValType> // сложение
TVector<ValType> TVector<ValType>::operator+(const TVector<ValType> &v)
{
    if (Size != v.Size)
        throw "Different sizes";
    TVector tmp(Size, StartIndex);
    for (int i = 0; i < Size; i++)
        tmp.pVector[i] = pVector[i] + v.pVector[i];
    return tmp;
} /*-------------------------------------------------------------------------*/

template <class ValType> // вычитание
TVector<ValType> TVector<ValType>::operator-(const TVector<ValType> &v)
{
    if (Size != v.Size)
        throw "Different sizes";
    TVector tmp(Size, StartIndex);
    for (int i = 0; i < Size; i++)
        tmp.pVector[i] = pVector[i] - v.pVector[i];
    return tmp;
} /*-------------------------------------------------------------------------*/

template <class ValType> // скалярное произведение
ValType TVector<ValType>::operator*(const TVector<ValType> &v)
{
    if (Size != v.Size)
        throw "Different sizes";
    int tmp = 0;
    for (int i = 0; i < Size; i++)
        tmp = tmp + v.pVector[i] * pVector[i];
    return tmp;
} /*-------------------------------------------------------------------------*/


@@ -157,6 +235,12 @@ class TMatrix : public TVector<TVector<ValType> >
template <class ValType>
TMatrix<ValType>::TMatrix(int s): TVector<TVector<ValType> >(s)
{
    if ((s < 0) || s > MAX_MATRIX_SIZE)
        throw "Bad length";
    if (StartIndex >= MAX_MATRIX_SIZE)
        throw(StartIndex);
    for (int i = 0; i < s; i++)
        pVector[i] = TVector<ValType>(s - i, i);
} /*-------------------------------------------------------------------------*/

template <class ValType> // конструктор копирования
@@ -170,26 +254,59 @@ TMatrix<ValType>::TMatrix(const TVector<TVector<ValType> > &mt):
template <class ValType> // сравнение
bool TMatrix<ValType>::operator==(const TMatrix<ValType> &mt) const
{
    if (Size != mt.Size)
        return false;
    for (int i = 0; i < Size; i++)
    {
        if (pVector[i] != mt.pVector[i])
            return false;
    }
    return true;
} /*-------------------------------------------------------------------------*/

template <class ValType> // сравнение
bool TMatrix<ValType>::operator!=(const TMatrix<ValType> &mt) const
{
    if (*this == mt)
        return false;
    else
        return true;
} /*-------------------------------------------------------------------------*/

template <class ValType> // присваивание
TMatrix<ValType>& TMatrix<ValType>::operator=(const TMatrix<ValType> &mt)
{
    if (*this != mt)
    {
        if (Size != mt.Size)
        {
            delete[]pVector;
            pVector = new TVector<ValType>[mt.Size];
        }
        Size = mt.Size;
        StartIndex = mt.StartIndex;
        for (int i = 0; i < Size; i++)
            pVector[i] = mt.pVector[i];
    }
    return *this;
} /*-------------------------------------------------------------------------*/

template <class ValType> // сложение
TMatrix<ValType> TMatrix<ValType>::operator+(const TMatrix<ValType> &mt)
{
    if (Size == mt.Size)
        return TVector< TVector<ValType> >::operator+(mt);
    else
        throw "Different sizes";
} /*-------------------------------------------------------------------------*/

template <class ValType> // вычитание
TMatrix<ValType> TMatrix<ValType>::operator-(const TMatrix<ValType> &mt)
{
    if (Size == mt.Size)
        return TVector< TVector<ValType> >::operator-(mt);
    else
        throw "Different sizes";
